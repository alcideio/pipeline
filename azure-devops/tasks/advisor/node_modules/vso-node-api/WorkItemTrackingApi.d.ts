import basem = require('./ClientApiBases');
import VsoBaseInterfaces = require('./interfaces/common/VsoBaseInterfaces');
import TfsCoreInterfaces = require("./interfaces/CoreInterfaces");
import VSSInterfaces = require("./interfaces/common/VSSInterfaces");
import WorkItemTrackingInterfaces = require("./interfaces/WorkItemTrackingInterfaces");
export interface IWorkItemTrackingApi extends basem.ClientApiBase {
    createAttachment(customHeaders: any, contentStream: NodeJS.ReadableStream, fileName?: string, uploadType?: string): Promise<WorkItemTrackingInterfaces.AttachmentReference>;
    getAttachmentContent(id: string, fileName?: string): Promise<NodeJS.ReadableStream>;
    getAttachmentZip(id: string, fileName?: string): Promise<NodeJS.ReadableStream>;
    getRootNodes(project: string, depth?: number): Promise<WorkItemTrackingInterfaces.WorkItemClassificationNode[]>;
    createOrUpdateClassificationNode(postedNode: WorkItemTrackingInterfaces.WorkItemClassificationNode, project: string, structureGroup: WorkItemTrackingInterfaces.TreeStructureGroup, path?: string): Promise<WorkItemTrackingInterfaces.WorkItemClassificationNode>;
    deleteClassificationNode(project: string, structureGroup: WorkItemTrackingInterfaces.TreeStructureGroup, path?: string, reclassifyId?: number): Promise<void>;
    getClassificationNode(project: string, structureGroup: WorkItemTrackingInterfaces.TreeStructureGroup, path?: string, depth?: number): Promise<WorkItemTrackingInterfaces.WorkItemClassificationNode>;
    updateClassificationNode(postedNode: WorkItemTrackingInterfaces.WorkItemClassificationNode, project: string, structureGroup: WorkItemTrackingInterfaces.TreeStructureGroup, path?: string): Promise<WorkItemTrackingInterfaces.WorkItemClassificationNode>;
    getComment(id: number, revision: number): Promise<WorkItemTrackingInterfaces.WorkItemComment>;
    getComments(id: number, fromRevision?: number, top?: number, order?: WorkItemTrackingInterfaces.CommentSortOrder): Promise<WorkItemTrackingInterfaces.WorkItemComments>;
    getField(field: string): Promise<WorkItemTrackingInterfaces.WorkItemField>;
    getFields(expand?: WorkItemTrackingInterfaces.GetFieldsExpand): Promise<WorkItemTrackingInterfaces.WorkItemField[]>;
    getHistory(id: number, top?: number, skip?: number): Promise<WorkItemTrackingInterfaces.WorkItemHistory[]>;
    getHistoryById(id: number, revisionNumber: number): Promise<WorkItemTrackingInterfaces.WorkItemHistory>;
    createQuery(postedQuery: WorkItemTrackingInterfaces.QueryHierarchyItem, project: string, query: string): Promise<WorkItemTrackingInterfaces.QueryHierarchyItem>;
    deleteQuery(project: string, query: string): Promise<void>;
    getQueries(project: string, expand?: WorkItemTrackingInterfaces.QueryExpand, depth?: number, includeDeleted?: boolean): Promise<WorkItemTrackingInterfaces.QueryHierarchyItem[]>;
    getQuery(project: string, query: string, expand?: WorkItemTrackingInterfaces.QueryExpand, depth?: number, includeDeleted?: boolean): Promise<WorkItemTrackingInterfaces.QueryHierarchyItem>;
    updateQuery(queryUpdate: WorkItemTrackingInterfaces.QueryHierarchyItem, project: string, query: string, undeleteDescendants?: boolean): Promise<WorkItemTrackingInterfaces.QueryHierarchyItem>;
    destroyWorkItem(id: number, project?: string): Promise<void>;
    getDeletedWorkItem(id: number, project?: string): Promise<WorkItemTrackingInterfaces.WorkItemDelete>;
    getDeletedWorkItems(project?: string, ids?: number[]): Promise<WorkItemTrackingInterfaces.WorkItemDeleteReference[]>;
    restoreWorkItem(payload: WorkItemTrackingInterfaces.WorkItemDeleteUpdate, id: number, project?: string): Promise<WorkItemTrackingInterfaces.WorkItemDelete>;
    getRevision(id: number, revisionNumber: number, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem>;
    getRevisions(id: number, top?: number, skip?: number, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem[]>;
    evaluateRulesOnField(ruleEngineInput: WorkItemTrackingInterfaces.FieldsToEvaluate): Promise<void>;
    createTemplate(template: WorkItemTrackingInterfaces.WorkItemTemplate, teamContext: TfsCoreInterfaces.TeamContext): Promise<WorkItemTrackingInterfaces.WorkItemTemplate>;
    getTemplates(teamContext: TfsCoreInterfaces.TeamContext, workitemtypename?: string): Promise<WorkItemTrackingInterfaces.WorkItemTemplateReference[]>;
    deleteTemplate(teamContext: TfsCoreInterfaces.TeamContext, templateId: string): Promise<void>;
    getTemplate(teamContext: TfsCoreInterfaces.TeamContext, templateId: string): Promise<WorkItemTrackingInterfaces.WorkItemTemplate>;
    replaceTemplate(templateContent: WorkItemTrackingInterfaces.WorkItemTemplate, teamContext: TfsCoreInterfaces.TeamContext, templateId: string): Promise<WorkItemTrackingInterfaces.WorkItemTemplate>;
    getUpdate(id: number, updateNumber: number): Promise<WorkItemTrackingInterfaces.WorkItemUpdate>;
    getUpdates(id: number, top?: number, skip?: number): Promise<WorkItemTrackingInterfaces.WorkItemUpdate[]>;
    queryByWiql(wiql: WorkItemTrackingInterfaces.Wiql, teamContext?: TfsCoreInterfaces.TeamContext, timePrecision?: boolean, top?: number): Promise<WorkItemTrackingInterfaces.WorkItemQueryResult>;
    queryById(id: string, teamContext?: TfsCoreInterfaces.TeamContext, timePrecision?: boolean): Promise<WorkItemTrackingInterfaces.WorkItemQueryResult>;
    getReportingLinks(project?: string, types?: string[], continuationToken?: string, startDateTime?: Date): Promise<WorkItemTrackingInterfaces.ReportingWorkItemLinksBatch>;
    getRelationType(relation: string): Promise<WorkItemTrackingInterfaces.WorkItemRelationType>;
    getRelationTypes(): Promise<WorkItemTrackingInterfaces.WorkItemRelationType[]>;
    readReportingRevisionsGet(project?: string, fields?: string[], types?: string[], continuationToken?: string, startDateTime?: Date, includeIdentityRef?: boolean, includeDeleted?: boolean, includeTagRef?: boolean, includeLatestOnly?: boolean, expand?: WorkItemTrackingInterfaces.ReportingRevisionsExpand): Promise<WorkItemTrackingInterfaces.ReportingWorkItemRevisionsBatch>;
    readReportingRevisionsPost(filter: WorkItemTrackingInterfaces.ReportingWorkItemRevisionsFilter, project?: string, continuationToken?: string, startDateTime?: Date, expand?: WorkItemTrackingInterfaces.ReportingRevisionsExpand): Promise<WorkItemTrackingInterfaces.ReportingWorkItemRevisionsBatch>;
    deleteWorkItem(id: number, destroy?: boolean): Promise<WorkItemTrackingInterfaces.WorkItemDelete>;
    getWorkItem(id: number, fields?: string[], asOf?: Date, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem>;
    getWorkItems(ids: number[], fields?: string[], asOf?: Date, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem[]>;
    updateWorkItem(customHeaders: any, document: VSSInterfaces.JsonPatchDocument, id: number, validateOnly?: boolean, bypassRules?: boolean): Promise<WorkItemTrackingInterfaces.WorkItem>;
    createWorkItem(customHeaders: any, document: VSSInterfaces.JsonPatchDocument, project: string, type: string, validateOnly?: boolean, bypassRules?: boolean): Promise<WorkItemTrackingInterfaces.WorkItem>;
    getWorkItemTemplate(project: string, type: string, fields?: string, asOf?: Date, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem>;
    getWorkItemTypeCategories(project: string): Promise<WorkItemTrackingInterfaces.WorkItemTypeCategory[]>;
    getWorkItemTypeCategory(project: string, category: string): Promise<WorkItemTrackingInterfaces.WorkItemTypeCategory>;
    getWorkItemType(project: string, type: string): Promise<WorkItemTrackingInterfaces.WorkItemType>;
    getWorkItemTypes(project: string): Promise<WorkItemTrackingInterfaces.WorkItemType[]>;
    getDependentFields(project: string, type: string, field: string): Promise<WorkItemTrackingInterfaces.FieldDependentRule>;
    exportWorkItemTypeDefinition(project?: string, type?: string, exportGlobalLists?: boolean): Promise<WorkItemTrackingInterfaces.WorkItemTypeTemplate>;
    updateWorkItemTypeDefinition(updateModel: WorkItemTrackingInterfaces.WorkItemTypeTemplateUpdateModel, project?: string): Promise<WorkItemTrackingInterfaces.ProvisioningResult>;
}
export declare class WorkItemTrackingApi extends basem.ClientApiBase implements IWorkItemTrackingApi {
    constructor(baseUrl: string, handlers: VsoBaseInterfaces.IRequestHandler[]);
    /**
    * Creates an attachment.
    *
    * @param {NodeJS.ReadableStream} contentStream - Content to upload
    * @param {string} fileName
    * @param {string} uploadType
    */
    createAttachment(customHeaders: any, contentStream: NodeJS.ReadableStream, fileName?: string, uploadType?: string): Promise<WorkItemTrackingInterfaces.AttachmentReference>;
    /**
    * Returns an attachment
    *
    * @param {string} id
    * @param {string} fileName
    */
    getAttachmentContent(id: string, fileName?: string): Promise<NodeJS.ReadableStream>;
    /**
    * Returns an attachment
    *
    * @param {string} id
    * @param {string} fileName
    */
    getAttachmentZip(id: string, fileName?: string): Promise<NodeJS.ReadableStream>;
    /**
    * @param {string} project - Project ID or project name
    * @param {number} depth
    */
    getRootNodes(project: string, depth?: number): Promise<WorkItemTrackingInterfaces.WorkItemClassificationNode[]>;
    /**
    * @param {WorkItemTrackingInterfaces.WorkItemClassificationNode} postedNode
    * @param {string} project - Project ID or project name
    * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup
    * @param {string} path
    */
    createOrUpdateClassificationNode(postedNode: WorkItemTrackingInterfaces.WorkItemClassificationNode, project: string, structureGroup: WorkItemTrackingInterfaces.TreeStructureGroup, path?: string): Promise<WorkItemTrackingInterfaces.WorkItemClassificationNode>;
    /**
    * @param {string} project - Project ID or project name
    * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup
    * @param {string} path
    * @param {number} reclassifyId
    */
    deleteClassificationNode(project: string, structureGroup: WorkItemTrackingInterfaces.TreeStructureGroup, path?: string, reclassifyId?: number): Promise<void>;
    /**
    * @param {string} project - Project ID or project name
    * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup
    * @param {string} path
    * @param {number} depth
    */
    getClassificationNode(project: string, structureGroup: WorkItemTrackingInterfaces.TreeStructureGroup, path?: string, depth?: number): Promise<WorkItemTrackingInterfaces.WorkItemClassificationNode>;
    /**
    * @param {WorkItemTrackingInterfaces.WorkItemClassificationNode} postedNode
    * @param {string} project - Project ID or project name
    * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup
    * @param {string} path
    */
    updateClassificationNode(postedNode: WorkItemTrackingInterfaces.WorkItemClassificationNode, project: string, structureGroup: WorkItemTrackingInterfaces.TreeStructureGroup, path?: string): Promise<WorkItemTrackingInterfaces.WorkItemClassificationNode>;
    /**
    * Returns comment for a work item at the specified revision
    *
    * @param {number} id
    * @param {number} revision
    */
    getComment(id: number, revision: number): Promise<WorkItemTrackingInterfaces.WorkItemComment>;
    /**
    * Returns specified number of comments for a work item from the specified revision
    *
    * @param {number} id - Work item id
    * @param {number} fromRevision - Revision from which comments are to be fetched
    * @param {number} top - The number of comments to return
    * @param {WorkItemTrackingInterfaces.CommentSortOrder} order - Ascending or descending by revision id
    */
    getComments(id: number, fromRevision?: number, top?: number, order?: WorkItemTrackingInterfaces.CommentSortOrder): Promise<WorkItemTrackingInterfaces.WorkItemComments>;
    /**
    * Gets information on a specific field.
    *
    * @param {string} field - Field name
    */
    getField(field: string): Promise<WorkItemTrackingInterfaces.WorkItemField>;
    /**
    * Returns information for all fields.
    *
    * @param {WorkItemTrackingInterfaces.GetFieldsExpand} expand - Use ExtensionFields to include extension fields, otherwise exclude them. Unless the feature flag for this parameter is enabled, extension fields are always included.
    */
    getFields(expand?: WorkItemTrackingInterfaces.GetFieldsExpand): Promise<WorkItemTrackingInterfaces.WorkItemField[]>;
    /**
    * Returns history of all revision for a given work item ID
    *
    * @param {number} id
    * @param {number} top
    * @param {number} skip
    */
    getHistory(id: number, top?: number, skip?: number): Promise<WorkItemTrackingInterfaces.WorkItemHistory[]>;
    /**
    * Returns the history value of particular revision
    *
    * @param {number} id
    * @param {number} revisionNumber
    */
    getHistoryById(id: number, revisionNumber: number): Promise<WorkItemTrackingInterfaces.WorkItemHistory>;
    /**
    * Creates a query, or moves a query.
    *
    * @param {WorkItemTrackingInterfaces.QueryHierarchyItem} postedQuery - The query to create.
    * @param {string} project - Project ID or project name
    * @param {string} query - The parent path for the query to create.
    */
    createQuery(postedQuery: WorkItemTrackingInterfaces.QueryHierarchyItem, project: string, query: string): Promise<WorkItemTrackingInterfaces.QueryHierarchyItem>;
    /**
    * @param {string} project - Project ID or project name
    * @param {string} query
    */
    deleteQuery(project: string, query: string): Promise<void>;
    /**
    * Retrieves all queries the user has access to in the current project
    *
    * @param {string} project - Project ID or project name
    * @param {WorkItemTrackingInterfaces.QueryExpand} expand
    * @param {number} depth
    * @param {boolean} includeDeleted
    */
    getQueries(project: string, expand?: WorkItemTrackingInterfaces.QueryExpand, depth?: number, includeDeleted?: boolean): Promise<WorkItemTrackingInterfaces.QueryHierarchyItem[]>;
    /**
    * Retrieves a single query by project and either id or path
    *
    * @param {string} project - Project ID or project name
    * @param {string} query
    * @param {WorkItemTrackingInterfaces.QueryExpand} expand
    * @param {number} depth
    * @param {boolean} includeDeleted
    */
    getQuery(project: string, query: string, expand?: WorkItemTrackingInterfaces.QueryExpand, depth?: number, includeDeleted?: boolean): Promise<WorkItemTrackingInterfaces.QueryHierarchyItem>;
    /**
    * @param {WorkItemTrackingInterfaces.QueryHierarchyItem} queryUpdate
    * @param {string} project - Project ID or project name
    * @param {string} query
    * @param {boolean} undeleteDescendants
    */
    updateQuery(queryUpdate: WorkItemTrackingInterfaces.QueryHierarchyItem, project: string, query: string, undeleteDescendants?: boolean): Promise<WorkItemTrackingInterfaces.QueryHierarchyItem>;
    /**
    * @param {number} id
    * @param {string} project - Project ID or project name
    */
    destroyWorkItem(id: number, project?: string): Promise<void>;
    /**
    * @param {number} id
    * @param {string} project - Project ID or project name
    */
    getDeletedWorkItem(id: number, project?: string): Promise<WorkItemTrackingInterfaces.WorkItemDelete>;
    /**
    * @param {string} project - Project ID or project name
    * @param {number[]} ids
    */
    getDeletedWorkItems(project?: string, ids?: number[]): Promise<WorkItemTrackingInterfaces.WorkItemDeleteReference[]>;
    /**
    * @param {WorkItemTrackingInterfaces.WorkItemDeleteUpdate} payload
    * @param {number} id
    * @param {string} project - Project ID or project name
    */
    restoreWorkItem(payload: WorkItemTrackingInterfaces.WorkItemDeleteUpdate, id: number, project?: string): Promise<WorkItemTrackingInterfaces.WorkItemDelete>;
    /**
    * Returns a fully hydrated work item for the requested revision
    *
    * @param {number} id
    * @param {number} revisionNumber
    * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
    */
    getRevision(id: number, revisionNumber: number, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem>;
    /**
    * Returns the list of fully hydrated work item revisions, paged.
    *
    * @param {number} id
    * @param {number} top
    * @param {number} skip
    * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
    */
    getRevisions(id: number, top?: number, skip?: number, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem[]>;
    /**
    * Validates the fields values.
    *
    * @param {WorkItemTrackingInterfaces.FieldsToEvaluate} ruleEngineInput
    */
    evaluateRulesOnField(ruleEngineInput: WorkItemTrackingInterfaces.FieldsToEvaluate): Promise<void>;
    /**
    * Creates a template
    *
    * @param {WorkItemTrackingInterfaces.WorkItemTemplate} template - Template contents
    * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
    */
    createTemplate(template: WorkItemTrackingInterfaces.WorkItemTemplate, teamContext: TfsCoreInterfaces.TeamContext): Promise<WorkItemTrackingInterfaces.WorkItemTemplate>;
    /**
    * Gets template
    *
    * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
    * @param {string} workitemtypename - Optional, When specified returns templates for given Work item type.
    */
    getTemplates(teamContext: TfsCoreInterfaces.TeamContext, workitemtypename?: string): Promise<WorkItemTrackingInterfaces.WorkItemTemplateReference[]>;
    /**
    * Deletes the template with given id
    *
    * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
    * @param {string} templateId - Template id
    */
    deleteTemplate(teamContext: TfsCoreInterfaces.TeamContext, templateId: string): Promise<void>;
    /**
    * Gets the template with specified id
    *
    * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
    * @param {string} templateId - Template Id
    */
    getTemplate(teamContext: TfsCoreInterfaces.TeamContext, templateId: string): Promise<WorkItemTrackingInterfaces.WorkItemTemplate>;
    /**
    * Replace template contents
    *
    * @param {WorkItemTrackingInterfaces.WorkItemTemplate} templateContent - Template contents to replace with
    * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
    * @param {string} templateId - Template id
    */
    replaceTemplate(templateContent: WorkItemTrackingInterfaces.WorkItemTemplate, teamContext: TfsCoreInterfaces.TeamContext, templateId: string): Promise<WorkItemTrackingInterfaces.WorkItemTemplate>;
    /**
    * Returns a single update for a work item
    *
    * @param {number} id
    * @param {number} updateNumber
    */
    getUpdate(id: number, updateNumber: number): Promise<WorkItemTrackingInterfaces.WorkItemUpdate>;
    /**
    * Returns a the deltas between work item revisions
    *
    * @param {number} id
    * @param {number} top
    * @param {number} skip
    */
    getUpdates(id: number, top?: number, skip?: number): Promise<WorkItemTrackingInterfaces.WorkItemUpdate[]>;
    /**
    * Gets the results of the query.
    *
    * @param {WorkItemTrackingInterfaces.Wiql} wiql - The query containing the wiql.
    * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
    * @param {boolean} timePrecision
    * @param {number} top
    */
    queryByWiql(wiql: WorkItemTrackingInterfaces.Wiql, teamContext?: TfsCoreInterfaces.TeamContext, timePrecision?: boolean, top?: number): Promise<WorkItemTrackingInterfaces.WorkItemQueryResult>;
    /**
    * Gets the results of the query by id.
    *
    * @param {string} id - The query id.
    * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
    * @param {boolean} timePrecision
    */
    queryById(id: string, teamContext?: TfsCoreInterfaces.TeamContext, timePrecision?: boolean): Promise<WorkItemTrackingInterfaces.WorkItemQueryResult>;
    /**
    * Get a batch of work item links
    *
    * @param {string} project - Project ID or project name
    * @param {string[]} types - A list of types to filter the results to specific work item types. Omit this parameter to get work item links of all work item types.
    * @param {string} continuationToken - Specifies the continuationToken to start the batch from. Omit this parameter to get the first batch of links.
    * @param {Date} startDateTime - Date/time to use as a starting point for link changes. Only link changes that occurred after that date/time will be returned. Cannot be used in conjunction with 'watermark' parameter.
    */
    getReportingLinks(project?: string, types?: string[], continuationToken?: string, startDateTime?: Date): Promise<WorkItemTrackingInterfaces.ReportingWorkItemLinksBatch>;
    /**
    * Gets the work item relation types.
    *
    * @param {string} relation
    */
    getRelationType(relation: string): Promise<WorkItemTrackingInterfaces.WorkItemRelationType>;
    /**
    */
    getRelationTypes(): Promise<WorkItemTrackingInterfaces.WorkItemRelationType[]>;
    /**
    * Get a batch of work item revisions with the option of including deleted items
    *
    * @param {string} project - Project ID or project name
    * @param {string[]} fields - A list of fields to return in work item revisions. Omit this parameter to get all reportable fields.
    * @param {string[]} types - A list of types to filter the results to specific work item types. Omit this parameter to get work item revisions of all work item types.
    * @param {string} continuationToken - Specifies the watermark to start the batch from. Omit this parameter to get the first batch of revisions.
    * @param {Date} startDateTime - Date/time to use as a starting point for revisions, all revisions will occur after this date/time. Cannot be used in conjunction with 'watermark' parameter.
    * @param {boolean} includeIdentityRef - Return an identity reference instead of a string value for identity fields.
    * @param {boolean} includeDeleted - Specify if the deleted item should be returned.
    * @param {boolean} includeTagRef - Specify if the tag objects should be returned for System.Tags field.
    * @param {boolean} includeLatestOnly - Return only the latest revisions of work items, skipping all historical revisions
    * @param {WorkItemTrackingInterfaces.ReportingRevisionsExpand} expand
    */
    readReportingRevisionsGet(project?: string, fields?: string[], types?: string[], continuationToken?: string, startDateTime?: Date, includeIdentityRef?: boolean, includeDeleted?: boolean, includeTagRef?: boolean, includeLatestOnly?: boolean, expand?: WorkItemTrackingInterfaces.ReportingRevisionsExpand): Promise<WorkItemTrackingInterfaces.ReportingWorkItemRevisionsBatch>;
    /**
    * Get a batch of work item revisions
    *
    * @param {WorkItemTrackingInterfaces.ReportingWorkItemRevisionsFilter} filter - An object that contains request settings: field filter, type filter, identity format
    * @param {string} project - Project ID or project name
    * @param {string} continuationToken - Specifies the watermark to start the batch from. Omit this parameter to get the first batch of revisions.
    * @param {Date} startDateTime - Date/time to use as a starting point for revisions, all revisions will occur after this date/time. Cannot be used in conjunction with 'watermark' parameter.
    * @param {WorkItemTrackingInterfaces.ReportingRevisionsExpand} expand
    */
    readReportingRevisionsPost(filter: WorkItemTrackingInterfaces.ReportingWorkItemRevisionsFilter, project?: string, continuationToken?: string, startDateTime?: Date, expand?: WorkItemTrackingInterfaces.ReportingRevisionsExpand): Promise<WorkItemTrackingInterfaces.ReportingWorkItemRevisionsBatch>;
    /**
    * @param {number} id
    * @param {boolean} destroy
    */
    deleteWorkItem(id: number, destroy?: boolean): Promise<WorkItemTrackingInterfaces.WorkItemDelete>;
    /**
    * Returns a single work item
    *
    * @param {number} id
    * @param {string[]} fields
    * @param {Date} asOf
    * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
    */
    getWorkItem(id: number, fields?: string[], asOf?: Date, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem>;
    /**
    * Returns a list of work items
    *
    * @param {number[]} ids
    * @param {string[]} fields
    * @param {Date} asOf
    * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
    */
    getWorkItems(ids: number[], fields?: string[], asOf?: Date, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem[]>;
    /**
    * @param {VSSInterfaces.JsonPatchDocument} document
    * @param {number} id
    * @param {boolean} validateOnly
    * @param {boolean} bypassRules
    */
    updateWorkItem(customHeaders: any, document: VSSInterfaces.JsonPatchDocument, id: number, validateOnly?: boolean, bypassRules?: boolean): Promise<WorkItemTrackingInterfaces.WorkItem>;
    /**
    * @param {VSSInterfaces.JsonPatchDocument} document
    * @param {string} project - Project ID or project name
    * @param {string} type
    * @param {boolean} validateOnly
    * @param {boolean} bypassRules
    */
    createWorkItem(customHeaders: any, document: VSSInterfaces.JsonPatchDocument, project: string, type: string, validateOnly?: boolean, bypassRules?: boolean): Promise<WorkItemTrackingInterfaces.WorkItem>;
    /**
    * Returns a single work item from a template
    *
    * @param {string} project - Project ID or project name
    * @param {string} type
    * @param {string} fields
    * @param {Date} asOf
    * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
    */
    getWorkItemTemplate(project: string, type: string, fields?: string, asOf?: Date, expand?: WorkItemTrackingInterfaces.WorkItemExpand): Promise<WorkItemTrackingInterfaces.WorkItem>;
    /**
    * @param {string} project - Project ID or project name
    */
    getWorkItemTypeCategories(project: string): Promise<WorkItemTrackingInterfaces.WorkItemTypeCategory[]>;
    /**
    * Returns a the deltas between work item revisions
    *
    * @param {string} project - Project ID or project name
    * @param {string} category
    */
    getWorkItemTypeCategory(project: string, category: string): Promise<WorkItemTrackingInterfaces.WorkItemTypeCategory>;
    /**
    * Returns a the deltas between work item revisions
    *
    * @param {string} project - Project ID or project name
    * @param {string} type
    */
    getWorkItemType(project: string, type: string): Promise<WorkItemTrackingInterfaces.WorkItemType>;
    /**
    * @param {string} project - Project ID or project name
    */
    getWorkItemTypes(project: string): Promise<WorkItemTrackingInterfaces.WorkItemType[]>;
    /**
    * Returns the dependent fields for the corresponding workitem type and fieldname
    *
    * @param {string} project - Project ID or project name
    * @param {string} type
    * @param {string} field
    */
    getDependentFields(project: string, type: string, field: string): Promise<WorkItemTrackingInterfaces.FieldDependentRule>;
    /**
    * Export work item type
    *
    * @param {string} project - Project ID or project name
    * @param {string} type
    * @param {boolean} exportGlobalLists
    */
    exportWorkItemTypeDefinition(project?: string, type?: string, exportGlobalLists?: boolean): Promise<WorkItemTrackingInterfaces.WorkItemTypeTemplate>;
    /**
    * Add/updates a work item type
    *
    * @param {WorkItemTrackingInterfaces.WorkItemTypeTemplateUpdateModel} updateModel
    * @param {string} project - Project ID or project name
    */
    updateWorkItemTypeDefinition(updateModel: WorkItemTrackingInterfaces.WorkItemTypeTemplateUpdateModel, project?: string): Promise<WorkItemTrackingInterfaces.ProvisioningResult>;
}
